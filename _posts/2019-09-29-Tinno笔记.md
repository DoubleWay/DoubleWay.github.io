---
layout:     post                    
title:      TINNO笔记                
subtitle:   Hello 
date:       2019-09-29              
author:     DoubleWay                      
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       
tags:                               
    - TINNO
---
安装JDK用命令装，
1. 添加openjdk8的第三方源
sudo add-apt-repository ppa:openjdk-r/ppa
2. 执行更新
apt-get update
3. 安装openjdk8
sudo apt-get install openjdk-8-jdk
4. 选择版本
sudo update-alternatives –config Java
5. 确认安装成功
java -version
openjdk version "1.8.0_91"

配置文件
gedit ~/.bashrc
###############################################3
将repo文件放到/usr/bin/ 下面，最好加一下权限，sudo chmod 777 /usr/bin/repo，从拷贝的位置执行命令sudo cp -r repo /usr/bin/
使用which repo，可以看repo是否已加载到环境变量中，ls -la |grep /usr/bin/repo,可以查看repo的权限
git安装：
sudo apt-get install git-core gitk git-man openssh-server openssh-client vim

config 放到/home/android/.ssh/ 下面
改一下用户名，改成自己的
identituFile ~/.ssh/id_rsa

host gerrit9
user can.wang
port 29418
hostname 192.168.33.9
identityFile ~/.ssh/id_rsa

host gerritscm
/////////////////////
在config里加上这些配置
host scm19
user git
hostname 172.16.20.19
identityFile ~/.ssh/id_rsa

配置编译环境
(1) 替换源,把我给的sources.list放到/etc/apt/下
smb://172.16.21.203/downloads/编译环境

(2) sudo apt-get update; sudo apt-get upgrade

第（2）步的时候，要连接外网。
sudo apt-get install gcc-multilib g++ g++-4.8-multilib dpkg-dev gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 libgl1-mesa-dev g++-multilib mingw32  tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386

#######################################################
1. 找 patch列表
cd .repo/manifests
git branch -a   ---> patch
gitk  xxxx/xxx/patch   -->  看最终
git checkout xxxx/xxx/patch  
看自己分支device下打到多少，将对应xml，复制到工具Allout。

Android7.0 打patch 步骤

1. 进入项目根目录
 	cd .repo/manifests 目录下 打开终端

2. 查看所有分支，找到复制patch分支
	 git branch -a

3. 获取所有分支xml文件，复制到工具目录下的patch目录
	git checkout xxxx/xxx/patch

4. 在manifests目录下切换分支到default分支,在项目目录下同步（repo sync）

	git checkout default

4. 执行工具目录下的脚本，获取要打patch的列表
	./start.sh

5. 进入相应的仓库，查看需要开始打patch的版本

	git branch -a  找到patch分支

	gitk  xxxx/xxx/patch

########################################################3
切换jdk为jdk8
/usr/lib/jvm/java-8-openjdk-amd64/bin/java -jar word.jar patch/ -2

##################################
repo status查看全局的状态 相当于git status 的全局

repo forall -p -c git status . 也是全局搜索


repo forall -p -c git push tinno HEAD:V3740AN_7.0_MEC_MX_V1.1全局提交 提交整个项目
####################################################################  
命令行切换java jdk
sudo update-alternatives --config java
#################################################################
flashtool  要用sudo命令打开

#############################################################
合并原型的步骤
一 提交
repo status (将本地修改全部提交)

二 更新
repo sync

三 合并
1. 按tag合并
git tag -l *3953*

git show xxx (tag名)

repo forall -p -c git merge xxx (tag名) > ./xxx.xml

2. 按分支合并
git branch -a

repo forall -p -c git merge remotes/tinno/V3911AN_7.0_V1.1 (分支名) > ./xxx.xml

四 冲突
一个一个解决冲突,然后打tag 提交或者直接提交

五 打tag 
repo forall -p -c git tag -f xxx
备注:直接提交的这步省略

六 提交
repo forall -p -c git push tinno xxx
也可以根据第三步生成的文件查看有关更新路径,进入每个仓库进行提交
##################################################################
一种强推的方式
git checkout P4601AN_6.0_CLF_PH_V2.1
git add
git commit
git tag -f P4601AN_6.0_CLF_PH_V2.1
git push tinno P4601AN_6.0_CLF_PH_V2.1 -f
#####################################################################
如果flash tools 无法刷机的话，把modemmanager卸载了
sudo apt-get remove modemanager
###########################################

编译软件,再编ota   make otapackage

拷贝两个版本target包

./build/tools/releasetools/ota_from_target_files  -s ./device/mediatek/build/releasetools/mt_ota_from_target_files  --block -k ./device/mediatek/common/security/mt6580/releasekey -i V3702AN_6.0_CEL_TN_BR1_04_TARGET.zip V3702AN_6.0_CEL_TN_BR1_08_TARGET.zip update04_08.zip



adb reboot recovery
####################################################################

make:如果不带任何参数，就是编译整个系统，make mediaPrivider 则是编译单个模块，但是会将这个模块所依赖的其他模块一起编译。mmm：编译指定目录下的模块，指定目录下必须有Android.mk文件，且不会编译它依赖的模块。 mm：编译当前目录下的模块，当前目录下必须有Android.mk文件，否则就往上找最近的Android.mk文件，也不会编译它以依赖的模块。mma：编译当前目录下的模块及其依赖项，当前目录新增或删除文件后，可以用mma重新编译。m：m命令就是对make进行简单的封装，也是对整个系统进行编译。
//////////////////////////////////////////////
 adb shell pm list features |grep PLUS  查看当前项目是不是empress plus项目
////////////////////////////////////////////////////////
在windows下安装刷机
1.sudo /usr/sbin/usermod -G vboxusers -a  android
2.重启一下ubuntu即可
3.cat /etc/group |grep vboxusers
4.runles.d解压考到 /etc/udev/rules.d 
5.权限chmod a+x ./*
6.ResearchDownload_R19.17.4301\Bin\BinPack  setting的LoadPolicy改为2
//////////////////////////////////////////////////////////////
宜宾同步命令
repo sync -c --no-tags -r YB
///////////////////////////////////////////////////////////////////////

-------------------------------------------------------------------

1. 添加 udev 规则

------------------------------------------------
> lsusb
Bus 003 Device 007: ID 12d1:1079 Huawei Technologies Co., Ltd. 

厂商ID(idVendor)：12d1，产品ID(idProduct)：1079

2. 编辑 /etc/udev/rules.d/xx-Android.rules文件

> sudo gedit 70-android.rules
	+ SUBSYSTEM=="usb", ATTRS{idVendor}=="12d1", ATTRS{idProduct}=="1079", MODE="0666"

3. 修改权限：
> sudo chmod 777 70-android.rules

4. 重新加载udev规则：> udevadm control --reload

5. 重启udev服务： > sudo service

6. 完成adb的重启
> sudo ./adb kill-server
> sudo ./adb start-server

////////////////////////////////////////////
----------------------------------------------------------------

MR项目流程-

-----------------------
SPM  VPM   软件工程师  
1.  跟SPM沟通项目配置  ， 新建提货单和  TSDS 编译配置
2.  本地提货单下拉代码  （如果跟随主干的分支走， 则不需要合并原型）
3.  客户需求导入jira   
4.  找spm  和 modem  硬件工程师沟通 参数配置， 还有新建对应订单的 仓库
5.  按照jira 上面的问题号， 修改需求
6.  需求本地验证OK 之后提交 代码
7.  需求改完之后， 进入tsds 编译版本   
8.  版本出完了之后 ，项目订单工程师下载验证，提供自检表 和 SVN版本路径给测试 进行全面测试验证。
9.  内部验证OK之后，  VPM  把版本提交给客户验证。
10. 客户确认版本， 内部要进行一轮GMS认证， 等到内部认证全部PASS之后，  提交给代理， 最后拿到google的 approve,  最后内部DCC
----------------------
SMR-
------------------------
1. 主要是谷歌的安全patch
2. GMS VERSION  不能修改，  base_os  属性值 你必须和你 DCC版本的fingerprint  一致
//////////////////////////////////////////////////

------------------------------------------------------

订单目录下各文件目录功能，配置文件：作用、路径

-------------------------------------------------

Android.mk：include all subdir makefile
apps/：预置客户APP
bootanimation：开关机动画资源
buildinfo.sh：项目相关定义的ro属性配置文档
configs.mk：控制device的宏定义，等订单项目配置makefile文件
etc：手机网络频段信息设置等相关信息
gms.mk：gms相关配置信息makefile文件
logo ： 手机开机第一帧图片和电池电量低图片
overlay：相关资源替换目录
sound : 手机铃声、通知、闹钟等音频文件配置信息
platformConfigs : 手机系统属性值配置文件

/////////////////////////////////////////////////

-----------------------------------------------

暗码：各常用暗码，及所进页面的作用（apk），常用测试或验证情景

----------------------------------------------------------------
（Google规范暗码：*#*#暗码#*#*）
0661：查看设备信息（LCD物料信息、TP物料信息、设备有的sensors、camera物料信息等）
86436：查看版本号（客户版本号，内部版本号，基线版本号等）
8：开机下的工厂测试（或称ftm测试，整机测试） 
        ps：关机下ftm测试--power+音量下键
84666364：工程模式--ylog，log level switch等...
*#06#：手机国际识别码（IMEI）

/////////////////////////////////////////////////

----------------------------

 第一步  制作动画压缩包  

-----------------------------------
zip -r -0 bootanimation.zip  ./  一定要命令行打包
然后删除里面的备份文件
2.  adb root   
3. adb remount
4. adb push bootanimation.zip   /system/media/
5. adb  reboot   看效果
开机铃声也是推到 /system/media/下

/////////////////////////////////////////

---------------------------------

在linux环境下更改图片的格式

-----------------------------------
1. 运行环境：Ubuntu

2. sudo apt install sam2p

3. 输入密码

4. 用cd命令到你图片所在文件路径

5. sam2p test.png test.eps  

///////////////////////////////////////
抓取log的命令 ：  adb logcat -v time >mylog.log
///////////////////////////////////////

------------------------------------------------------

Android 中的设置关于手机中的型号的更改

--------------------------------------------------
1.APPS-->Settings-->About phone-->Model number

通过Model number找到

./res/values/strings.xml:1738:    <string name="model_number">Model number</string>

2.通过定义model_number找xml文件

./res/xml/device_info_settings.xml:103:                android:title="@string/model_number"

        <!-- Device hardware model -->
        <Preference android:key="device_model" 
                style="?android:preferenceInformationStyle"
                android:title="@string/model_number"
                android:summary="@string/device_info_default"/>

3.通过Android的key，device_model找到到/src/com/android/settings/DeviceInfoSettings.java:58:  

private static final String KEY_DEVICE_MODEL= "device_model";

4.通过KEY_DEVICE_MODEL 找到

        setStringSummary(KEY_DEVICE_MODEL, Build.MODEL + getMsvSuffix());

是通过Build.MODEL来获得Model number的值

5.要找Build.MODEl要在全局frameworks/base/core/java/android/os中去找

frameworks/base/core/java/android/os/Build.java:56:  

public static final String MODEL = getString("ro.product.model");

6.ro.product.model一般定义在build目录中

build/tools/buildinfo.sh:18:echo "ro.product.model=$PRODUCT_MODEL"

7.找到ro.product.model=$PRODUCT_MODEL是通过$PRODUCT_MODEL的赋值的

那我们在回到Settings中看看是怎么定义的

8.通过PRODUCT_MODEL找到

./Android.mk:2:ifeq ($(PRODUCT_MODEL),T73)

这个里面是项目多时，定义的编译脚本，同事也给PRODUCT_MODEL赋值，

这个地方改动不了，那就回build/tools/buildinfo.sh改

将这句echo "ro.product.model=************"强制写死

 

 

更多直接在手机上修改，这些值也能在buildinfo.sh中找到：

（1） .确保手机已经root，下载可以修改手机文件的文件管理器(如RE文件浏览器)并安装在安卓手机端.  
（2）.进入re管理器，它会提示获取权限。点击允许。
（3）.进入到系统“/system/”路径下，然后找到此目录下的“build.prop。。按住这个文件，从弹出的菜单中选择用文本编辑器打开。
（4）找到“ro.product.model=...”这一行，“=”号后面的即你的手机型号，修改成其他的即可，找到“ro.product.brand=...”一行，修改“=”号后面的参数，即修改了手机品牌。
（5）在功能菜单中点击“保存”，接着退回到主界面，重启手机后所有的修改便会生效。
（6）重启手机后，打开“系统设置”，查找“关于手机”的字样，进入手机信息界面，你的手机型号便已经更改，当手机连接电脑后电脑端显示的手机型号也会改变。
以下是CM系统的build.prop文件的详解： 如下
# begin build properties （开始设置系统性能）
# autogenerated by buildinfo.sh （通过设置形成系统信息）
ro.build.id=GRI40 (版本ID)
ro.build.display.id=GRJ22 （版本号）
ro.build.version.incremental=eng.buildbot.20110619.060228 （版本增量）
ro.build.version.sdk=10 （sdk版本）
ro.build.version.codename=REL （版本代号）
ro.build.version.release=2.3.4 （Android 2.3.4系統无需修改，也可改为3.0）
ro.build.date=Sun Jun 19 06:02:58 UTC 2011 （制作者制作的时间，可修改2011年X月X日 某某某制作）
ro.build.date.utc=0
/////////////////////////////////////////////////

------------------------------------------------------------------------

内置APK应用  （apk应用，源码内置， RRO静态资源修改）

------------------------------------------------------------------------
   第一步：
      在 “/vendor/.../packages/apps” 目录下创建一个对应名称的文件夹。

   第二步：
   将所需apk放入文件夹中。

   第三步， 编辑 Android.mk ：

      LOCAL_PATH := $(call my-dir)
        include $(CLEAR_VARS)
        # Module name should match apk name to be installed.

        #设置apk的名字,XXX为apk名称
        LOCAL_MODULE := XXX
        LOCAL_SRC_FILES := $(LOCAL_MODULE).apk    
        LOCAL_MODULE_TAGS := optional
        LOCAL_MODULE_CLASS := APPS
        LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)

        #签名方式，如果是platform，代表签名成系统软件, 如果还是PRESIGND，表示用的是apk原本的签名。
        LOCAL_CERTIFICATE := platform

        #将apk编进“/system/priv-app/目录”，如果为false，或者不加这句话，就会编进“/system/app” 目录, 二者区别在于前者的权限要高于  后者
        LOCAL_PRIVILEGED_MODULE := true

      #（如果 LOCAL_MULTILIB 是32，意思是编译出32位的lib库，64异曲同工，如果是both，代表编译出两种库文件，  当然，首先要解压  apk，看看lib库是32的还是64的。  另外，如果手机系统是64位的，而lib库是32位的，则需要在  “/frameworks/base/services/core/java/com/android/serve/pm/PackageManagerService.java”   中进行配置， lineNumber ： 6221）
       LOCAL_MULTILIB := 32   
       include $(BUILD_PREBUILT)

 补充：　LOCAL_OVERRIDES_PACKAGES := Calculator　   #覆盖掉之前有的一个apk，名字叫Calculator



  第四步：
       在 /device/平台/.../项目目录下找到相应的版本，打开其中的 “项目名.mk” 文件， 添加：

         #编译项目时，会在对应的版本中添加上这个apk。   

         PRODUCT_PACKAGES += XXX

  第五步：
    编译一下整个项目，运行调试，就会将apk编进 "/system/priv-app/" 或 " /system/app"。

---------------------------------------------

查看apk的信息 

--------------------------------------------
使用Sdk/build-tools/ 
./aapt dump badging '/home/android/桌面/GmsCoreGo_arm_xhdpi.apk' |grep package

aapt l :简单的罗列压缩文件中每一项的内容

aapt l -a :详细输出压缩文件中所有目录的内容

aapt l -v XXX.apk :列表方式详细标识出压缩文件中的每一项和很多参数  (　Length 原始文件参数

　　　　Date 日期

　　　　Time 时间

　　　　Name 名称

　　　　Method压缩方法，Deflate及Stored两种，即该Zip目录采用的算法是压缩模式还是存储模式

　　　　Ratio 压缩率

　　　　Size 压缩省掉的大小

　　　　CRC-32 循环冗余校验 这个计算是特定的算法的

　　　　offset：zipfile中偏移量的意思 )

aapt dump strings  :打印apk中所有string资源表
aapt dump badging :查看apk中的配置信息
/////////////////////////////////////////////

------------------------------------------------

﻿debug 软件编译前修改点（用于gms的debug）

-------------------------------------------------
﻿debug 软件编译前修改点（用于gms的debug）
1、fingerprint属性与用于同次gms的user版本要一致，除了ro.build.type字段值不同
如：user版：Mobicel/X4/X4:8.1.0/OPM2.171019.012/1568094378:user/release-keys
则debug版： Mobicel/X4/X4:8.1.0/OPM2.171019.012/1568094378:userdebug/release-keys

2、incremental属性值修改---与user软件的值要一致，且与fingerprint中incremental字段值一致
基于上一次举例，要设置 ro.build.version.incremental=1568094378

3、tag属性值要与fingerprint中tag字段一致
基于上一次举例，要设置 ro.build.tags=release-keys
--------------------------------------------------

旧版本修改方式:

--------------------------------------------------
先在对应订单目录的buildinfo.mk查找fingerprint属性值的组成方式
，从本文件和configs.mk文件中查找对应的宏，如果找不到去device目录grep搜索
没有结果则从build/make/core/Makefile文件中查找本订单fingerprint赋值的位置，对
BUILD_NUMBER     TAGERT_BUILD_VARIANT   和release-keys 进行修改，如果是取宏则在订单目录修改，
release-keys可直接在buildinfo强改，并且/build/make/core/Makefile文件对应fingerprint也要修改。
注：如果TARGET_BUILD_VARIANT值是编译脚本中定义为直接从输入编译命令取值则不用修改。
//////////////////////////////////////////////////
